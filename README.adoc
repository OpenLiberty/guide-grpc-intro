// Copyright (c) 2022 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
// https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: grpc-intro
:page-layout: guide-multipane
:page-duration: 30 minutes
:page-releasedate: 2022-09-08
:page-description: Learn how to use gRPC unary, server streaming, client streaming, and bidirectional streaming to communicate client and server services in Open Liberty.
:page-tags: ['gRPC']
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/prod
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:page-seo-title: Communicating client and server services with gRPC streaming calls
:page-seo-description: A getting started tutorial with examples on how to run unary, server streaming, client streaming, and bidirectional streaming by using gRPC Remote Procedure Calls in Open Liberty.
:guide-author: Open Liberty
= Communicating client and server services with gRPC streaming calls

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use gRPC unary, server streaming, client streaming, and bidirectional streaming to communicate client and server services in Open Liberty.

// =================================================================================================
//  What you'll learn
// =================================================================================================

== What is gRPC?

gRPC Remote Procedure Call is a technology that implements remote procedure call (RPC) style APIs with HTTP/2. gRPC uses Protocol Buffers to define its routines that include service calls and expected messages. For each service defined in a `.proto` file, gRPC uses it to generate the skeleton code for users to implement and extend. Protocol buffers use a binary format to send and receive messages that are much faster and lightweight compared to JSON used in RESTful APIs.

Protocol buffers allow cross project support through the `.proto` file, as a result gRPC clients and servers are also able to run and communicate with each other on different environments. For example, a gRPC client running in Java codebase is able to call a gRPC server from a Python codebase. This feature of protocol buffers allows for easier integration between services.

== What you'll learn

You will learn how to create gRPC client and server services by using protocol buffers and how to implement them with Open Liberty. You will use Maven throughout the guide to generate the gRPC stubs and deploy the services and to interact with the running Liberty.

The application that you will build in this guide consists of the `systemproto` model project, the `query` client service, and the `system` server service. The `query` service implements four RESTful APIs by using four different gRPC streaming methods.

image::architecture.png[gRPC application architecture where the system service provides gRPC server and the query service to make different gRPC streaming calls. align="center"]

// =================================================================================================
// Getting Started
// =================================================================================================
[role='command']
include::{common-includes}/gitclone.adoc[]

=== Try what you'll build

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

To try out the application, first go to the `finish` directory and run the following Maven goal to generate all the gRPC abstract classes defined in the `.proto` file. 

// generate gRPC classes
[role='command']
----
cd finish
mvn -pl systemproto install
----

Start the `system` service by running the following command:
// starting system
[role='command']
----
mvn -pl system liberty:run
----

Next, open another command-line session and start the `query` service by using the following command:
// starting query
[role='command']
----
mvn -pl query liberty:run
----

Point your browser to the http://localhost:9081/query/properties/os.name URL to test out the basic unary service. You will see your operating system name. Next, point your browser to the following URLs to try out:

* client streaming - http://localhost:9081/query/properties/os 

* server streaming - http://localhost:9081/query/properties/user

* bidirectional streaming - http://localhost:9081/query/properties/java

Observe the output from the consoles running the `system` and `query` services.

After you are finished checking out the application, stop both the `query` and `system` services by pressing `CTRL+C` in the command-line sessions where you ran them. Alternatively, you can run the following goals from the `finish` directory in another command-line session:
// stopping dev mode
[role='command']
----
mvn -pl system liberty:stop
mvn -pl query liberty:stop
----

// =================================================================================================
// Creating proto file and generating gRPC stubs
// =================================================================================================

== Creating and defining gRPC services

Navigate to the `start` directory to begin.

First, create the `.proto` file and generate gRPC classes. You will implement the gRPC server with the generated classes later. The `.proto` file defines all the service calls and message types. The message types are used in the service call definition for the parameters and returns.

// Create SystemProto.proto
[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `SystemService.proto` file.#
`systemproto/src/main/proto/SystemService.proto`
----
SystemService.proto
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/systemproto/src/main/proto/SystemService.proto[]
----

// Import pom.xml
pom.xml
[source, XML, linenums, role="code_column"]
----
include::finish/systemproto/pom.xml[]
----

The first few lines define the [hotspot=basicConfig file=0]`syntax`, [hotspot=basicConfig file=0]`package`, and [hotspot=basicConfig file=0]`option` basic configuration of the `.proto` file. The [hotspot=SystemService file=0]`SystemService` service contains the four service calls that will be implemented in the coming sections.

The [hotspot=getProperty file=0]`getProperty` rpc defines the unary call. In this call, the client side sends a `SystemPropertyName` message to the server side that returns back a `SystemPropertyValue` message with the property value. The [hotspot=SystemPropertyName file=0]`SystemPropertyName` and [hotspot=SystemPropertyValue file=0]`SystemPropertyValue` message types define that the `propertyName` and `propertyValue` must be string.

The [hotspot=getPropertiesServer file=0]`getPropertiesServer` rpc defines the server streaming call. The client side sends a `SystemPropertyName` message to the server side. The server returns back a stream of `SystemProperty` messages. Each [hotspot=SystemProperty file=0]`SystemProperty` message contains a `propertyName` and `propertyValue`.

The [hotspot=getPropertiesClient file=0]`getPropertiesClient` rpc defines the client streaming call. The client side streams `SystemPropertyName` messages to the server side. The server returns back a [hotspot=SystemProperties file=0]`SystemProperties` message that contains a map of the properties with their respective values.


The [hotspot=getPropertiesBidirect file=0]`getPropertiesBidirect` rpc defines the bidirectional streaming call. In this service, the client side streams `SystemPropertyName` messages to the server side. The server returns back a stream of [hotspot=SystemProperty file=0]`SystemProperty` messages.

To compile the `.proto` file, the `pom.xml` Maven configuration file needs the  [hotspot=grpc file=1]`grpc-protobuf` and [hotspot=grpc-stub file=1]`grpc-stub` dependencies, and the [hotspot=protobufmavenplugin file=1]`protobuf-maven-plugin` plugin. To install the correct version of Protobuf compiler automatically, the [hotspot=osmavenplugin file=1]`os-maven-plugin` extension is required in the `build` configuration.

Run the following command to generate the gRPC classes.
// run mvn install to generate abstract classes
[role='command']
----
mvn -pl systeproto install
----

// =================================================================================================
// Implementing unary call
// =================================================================================================

== Implementing unary call

Start by implementing the first service call, the unary call. In this service call, the query service sends one property to the system service, which will return the property value. This type of service call resembles the RESTful API. 

Start the query service in dev mode by using the following command. 
// Commands for query service
// start dev mode for query
[role='command']
```
mvn -pl query liberty:dev
```

After you see the following message, your application server in dev mode is ready:

[role="no_copy"]
----
**************************************************************
*    Liberty is running in dev mode.
----

Dev mode holds your command-line session to listen for file changes. Open another command-line session to continue, or open the project in your editor.

// Create PropertiesResource
[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `PropertiesResource` class.#
`/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java`
----

PropertiesResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,serverStreaming,clientStreaming,bidirectionalStreaming"]
----
include::finish/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java[]
----
The `PropertiesResource` class provides endpoints to interact with the system service. The `/<propertiesName>` endpoint is a unary service call to get the property value from the system service. 

// update server.xml
[role='code_command hotspot file=1', subs="quotes"]
----
#Replace the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

server.xml
[source, xml, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/liberty/config/server.xml[]
----

The [hotspot=grpc file=1]`grpc-1.0` and [hotspot=grpcClient file=1]`grpcClient-1.0` enable gRPC compatibility with Open Liberty. 

Open another terminal window and start the system service in dev mode by using the following command. 
// Commands for system service
// start dev mode for system
[role='command']
```
mvn -pl system liberty:dev
```

The SystemService class implements the `SystemServiceGrpc` class that is generated by the proto file. The four types of services that are defined in the proto file will be implemented here. 
// Create SystemService
[role="code_command hotspot file=2", subs="quotes"]
----
#Create the `SystemService` class.#
`/system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

SystemService.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,getPropertiesServer,getPropertiesClient,getPropertiesBidirect"]
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The [hotspot=getProperty file=2]`getProperty()` is the implementation of the rpc call defined in the proto file. The [hotspot=pName file=2]`pName` variable stores the request string, notice the use of the getter `getPropertyName`, this is also automatically generated by gRPC. The [hotspot=pValue file=2]`pValue` gets and stores the System property value. The [hotspot=response file=2]`value` variable stores the built response to be sent back. Notice the variable type `SystemPropertyValue`, this is the message type that was defined in the proto file. The built response is then sent to the query service by using [hotspot=next file=2]`onNext()` and [hotspot=complete file=2]`onComplete()`

Open another terminal window and run the following curl command to test out the unary service. Replace `<propertiesName>` with the name of the property that you would like to see, an example is `os.name`. You should see your system os name in the terminal.

// curl request
[role='command']
----
curl http://localhost:9081/query/properties/<propertiesName>
----

// =================================================================================================
// Implementing server streaming  
// =================================================================================================

== Implementing server streaming 
The next service to implement is `Server Streaming`. The query service sends a request by using the `os` endpoint and the system service will streams the os properties back to the query service. There is a channel that is created between the query and the system service to stream properties. This channel is only closed by the system service after it has sent the last message to the query service. 

Replace the `PropertiesResource` class to add the implementation of serverSteraming for query service. 
// Commands for query service
// Replace PropertiesResource
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `PropertiesResource` class.#
`/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java`
----

PropertiesResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,clientStreaming,bidirectionalStreaming"]
----
include::finish/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java[]
----

First, a [hotspot=createChannel file=0]`channel` is created between query and system services by using the stubs that are generated by the proto file. Then, the properties are [hotspot=sendProperties file=0]`streamed` individually from the system service. After all of the properties are received, the [hotspot=closeConnection file=0]`channel` is closed. 

// Commands for system service
Update the SystemService class to include the implementation of `getOSProperties()`, which receives the os properties from the system service. 
// Replace SystemService
[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`/system/src/main/java/io/openliberty/guides/system/SystemService.java`
----
SystemService.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,clientStreaming,bidirectionalStreaming"]
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The [hotspot=getPropertiesServer file=1]`getPropertiesServer()` method implements server streaming for the system service. The properties are [hotspot=serverStreaming file=1]`individually streamed` to the query service. The message `server streaming was completed!` is printed in the system service terminal at the conclusion of the method. 


Run the following curl command to test out the server streaming.
You should see each property that was streamed from the system service to the query service and a message saying `server streaming completed`.
// curl request
[role='command']
----
curl http://localhost:9081/query/properties/os
----

// =================================================================================================
// Implementing client streaming 
// =================================================================================================


== Implementing client streaming 

The next service to implement is `Client Streaming`. The query service streams user properties to the system service by using the `user` endpoint and the system service returns a map of those user properties with their values.
// Commands for query service
// Replace PropertiesResource

Replace the `PropertiesResource` class to add the implementation of serverSteraming for query service. 
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `PropertiesResource` class.#
`/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java`
----

PropertiesResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,bidirectionalStreaming"]
----
include::finish/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java[]
----

After a connection is created between the two services, a [hotspot=defineClient file=0]`client` is defined to ensure the expected behavior. The [hotspot=getPropertiesClientStreaming file=0]`user properties` are [hotspot=clientStream file=0]`streamed` to the system service. 

// Commands for system service
// Replace SystemService
[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`/system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

SystemService.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright,bidirectionalStreaming"]
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The [hotspot=getPropertiesClient file=1]`getPropertiesClient()` method implements client streaming for the system service. In this method, system service [hotspot=receivingProperties file=1]`receives` the user properties from the query service and stores them in a [hotspot=clientStreamingMap file=1]`Map`, and after the streaming is completed the stored map is [hotspot=clientStreamingCompleted file=1]`returned` to the query service. 


Run the following curl command to test out the client streaming.
You should see each property that was streamed from the query service to the system service and a message saying `client streaming completed`.
// curl request
[role='command']
----
curl http://localhost:9081/query/properties/user
----

// =================================================================================================
// Implementing bidirectional streaming 
// =================================================================================================

== Implementing bidirectional streaming 
The next service to implement is `bidirectional Streaming`. The query service streams the Java properties while the system service streams the values of those properties back to the query service. 
// Commands for query service
// Replace PropertiesResource
[role="code_command hotspot file=0", subs="quotes"]
----
#Replace the `PropertiesResource` class.#
`/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java`
----

PropertiesResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/query/src/main/java/io/openliberty/guides/query/PropertiesResource.java[]
----

Similar to the client streaming service, the [hotspot=bidirectionalStreaming file=0]`bidirectional streaming` also receives streamed properties from the query service but in addition it also streams the values for the properties received back to the query service. 

// Commands for system service
// Replace SystemService
[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `SystemService` class.#
`/system/src/main/java/io/openliberty/guides/system/SystemService.java`
----

SystemService.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/system/src/main/java/io/openliberty/guides/system/SystemService.java[]
----

The [hotspot=getPropertiesBidirect file=1]`getPropertiesBidirect()` method implements bidirectional streaming for the system service. In this method, system service [hotspot=receiveBidirectionalProperties file=1]`receives and sends` the Java properties with their respective values back to the query service.


Run the following curl command to test out bidirectional streaming.
You should see each property that was streamed from the query service to the system as well from the system to the query service and a message saying `bidirectional streaming completed`.
// curl request
[role='command']
----
curl http://localhost:9081/query/properties/java
----

// =================================================================================================
// Testing the application
// =================================================================================================

== Testing the application
// Create QueryIT.java
[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `QueryIT` class.#
`finish/query/src/test/java/it/io/openliberty/guides/query/QueryIT.java`
----

QueryIT.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/query/src/test/java/it/io/openliberty/guides/query/QueryIT.java[]
----
Each test case tests one of the methods for instantiating a RESTful client.

The [hotspot=getPropertiesString file=0]`testGetPropertiesString()` tests the `http://localhost:9081/query/properties/os.name` endpoint and confirms that a response is received. 

The [hotspot=getOSProperties file=0]`testGetOSProperties()` tests the `http://localhost:9081/query/properties/os` endpoint and confirms that a response is received. 

The [hotspot=getUserProperties file=0]`testGetUserProperties()` tests the `http://localhost:9081/query/properties/user` endpoint and confirms that a response is received. 

The [hotspot=getJavaProperties file=0]`testGetJavaProperties()` tests the `http://localhost:9081/query/properties/java` endpoint and confirms that a response is received. 

[role=command]
include::{common-includes}/devmode-test.adoc[]

[source, role="no_copy"]
----
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running it.io.openliberty.guides.query.QueryIT
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.247 s - in it.io.openliberty.guides.query.QueryIT
[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] Integration tests finished.
----

When you are finished, exit dev mode by pressing `CTRL+C` in the
command-line session that the container was started from, or by typing `q` and
then pressing the `enter/return` key.

// =================================================================================================
// Great work! You're done!
// =================================================================================================

== Great work! You're done!

You just developed an application that implements four unique calls with gRPC by using Open Liberty. 

include::{common-includes}/attribution.adoc[subs="attributes"]
